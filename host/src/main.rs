// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    WINTERNITZ_ELF, WINTERNITZ_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use rand::Rng;
use rand::rngs::SmallRng;
use rand::SeedableRng;
use winternitz_core::{Parameters, sign_digits, generate_public_key};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:

    let n0 = 448;
    let log_d = 4;
    let params = Parameters::new(n0, log_d);

    let input: u64 = 1;

    let mut rng = SmallRng::seed_from_u64(input);

    let message: Vec<u32> = (0..n0).map(|_| rng.gen::<u32>() % log_d ).collect();

    let secret_key: Vec<u8> = (0..n0).map(|_| rng.gen()).collect();
    let pub_key: Vec<[u8; 20]> = generate_public_key(&params, &secret_key);

    let signature = sign_digits(&params, &secret_key, message);


    let env = ExecutorEnv::builder()
        .write(&pub_key)
        .unwrap()
        .write(&params)
        .unwrap()
        .write(&signature)
        .unwrap()
        .build()
        .unwrap();



    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, WINTERNITZ_ELF)
        .unwrap();
    println!("Proof generated!" );
    // extract the receipt.
    let receipt = prove_info.receipt;
    println!("Receipt extracted! {:?}", receipt);
    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    let _output: u32 = receipt.journal.decode().expect("Failed to decode journal");
    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt
        .verify(WINTERNITZ_ID)
        .unwrap();
}
